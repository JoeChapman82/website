{
    "pageTitle": "Make a game of Pong",
    "mainHeading": "Creating a Pong game",
    "authorHeading":"A tutorial by Joe Chapman",
    "subHeading1": "Introduction",
    "subHeading2": "Setting up",
    "subHeading3": "The player and ball methods",
    "subHeading4": "Rendering the game board",
    "subHeading5": "Setting up the game loop",
    "subHeading6": "Updating the ball",
    "subHeading7": "Updating the players",
    "subHeading8": "Adding event listeners",
    "subHeading9": "Finishing the main method",
    "subHeading10": "Complete code",
    "subHeading11": "Conclusion",
    "p1": "Pong, is a great game made in the early 70's by a company called Atari. It was one of the first games I ever played, bound by a cable, about a meter in front a 14 inch CRT television. The game itself may look quite simplistic, but it contains a lot of the basic building blocks found in any game. If you're wanting to learn how to program a game, it's a great place to start.",
    "p2": "This tutorial will cover everything needed to create everything that the original Pong contained. We'll cover a couple of different types of AI, collision detection, scoring and calculating the return trajectory when the ball hits the paddle. The game can be set up as one player or a demo match, with the ability to add two player functionality with just a couple of lines of code.",
    "p3": "We'll start of by creating a file called pong.html with some boilerplate code We'll need a canvas tag inside the body element. We'll give it an ID of demoCanvas so it's easy to get from out Javascript and we'll give it a width of 600 and a height of 300. We'll also screate a script tag at the bottom of the body tag with a src of pong.js",
    "p4": "Next, we'll create a file called pong.js in the same location as pong.html. We'll wrap all of out code in a imediately invoked function expression to create a new execution context and protect the global environment. Now, we'll set up our vairables: We'll use canvas and assign the canvas we just created in our HTML to it using getElementById. Next we'll assign the canvases 2d to ctx.",
    "p5": "We know that the game only consists of one colour, so we can also set the fill style here to white to save a bit of time later on. Were also going to need one font so we can set the font here too.",
    "p6": "Now we'll set some helper variables that will handle time within the game and ball velocity. We'll use lastTime and deltaTime and initialise them both to zero. We also need to assign 16 and 9 to worldHeight. Setup horizontalUnit to canvas.width / worldWidth and verticalUnit to canvas.height / worldHeight. Using a consistent measurement for width and height is a good habit to get into to ensure consistent movement across screen and device sizes.",
    "p7": "Finally, we'll initialise players to an empty array. We'll use this to store our players once they've been created. We'll also declare ball and invisiball which we'll use later, set a border width of 10 for our top and bottom border and a winScore of 10 because it's just not a game if you can't win.",
    "p8": "For the ball and the paddles we'll be using function constructors so we can create new ones as required.",
    "p9": "The ball will take 5 paramaters, but we'll provide defaults for all of them. We'll be basing the AI around a seperate ball, so seting it up like this means that we can easily pass an existing balls arguments. The ai ball will use the invisible boolean. Everything in here should be pretty standard: x and y positions, width, height, x velocity and y velocity. We'll start the ball in the center of the canvas and give the ball a 50/50 chance of positive or negative velocities to make the game fair.",
    "p10": "The player function will have very similar properties. We'll use a parameter to set which side of the court the player resides on and we'll also add boolean properties that we can tie to controls which will add with event listeners at the end of the tutorial. When creating game objects, it's a good idea to consistently set x, y, width and height properties, or radius for circular items as it will make sorting out collision detection a breeze.",
    "p11": "Now that we've set up all the variables, we'll add a couple of helper functions and render the main game board.",
    "p12": "We'll add a function to assign a value to delta time on each iteration of the game loop. This value represents the amount of time since the last frame was exectuted. Maping movement to time ensures a consistent experience regardless of the framerate the game runs at. We'll also check to see if the value is over half a second and set the value back to a normal 60 frames per second value if it is.",
    "p13": "We also need a function to calculate the return trajectory after a ball hits a paddle. We'll find the central y position of the ball and the player that has hit the ball, find the difference and set a return trajectory, which will be the balls new vy value to a percentage of the balls maxVy value relative to paddles central point. A positive or negative value is returned dependent on the ball hitting the top or bottom half of the paddle.",
    "p14": "Finally in the helper functions, we need collision detection. This function simply checks to see if there are any intersecting points within two rectangles that aren't rotated. As there are only a few calculations within the game, we can afford to run this function every frame without any worries.",
    "p16": "For our rendering methods, we're only going to need a handlful to handle all the rendering within the game. First we'll create a method for rendering filled rectangles which contains the standard canvas methods required for rendering rectangles. Everything within the game is composed solely of rectangles, so this will save us typing it out each time. Methods like this should prove useful in almost any game you make.",
    "p17": "The second method well use will form the dashed line down the center of the game board. We'll just use a for loop to draw a rectangle at even intervals down the center of the game board using the vertical unit we calculated at the start for spacing.",
    "p18": "We also need a method for rendering the top and bottom border of the play area, which again we'll create with two rectangles at the top and bottom of the game board, utilising our renderRect method that we created above and giving the rectangles the border width that we specified in the variables at the start.",
    "p19": "The last render method we need is for the scores. We'll set the text baseline property on the canvas context to hanging, so it's easy to position relative to the top border. Well then use the textAlign property of the context to easily position the scores at either side of the central line.",
    "p20": "We've got a decent amount of code written now, so we'll create an initialisation method and set up the game loop so that we can check that everythings working as expected.",
    "p21": "To start with we'll set up our initialisation and reset methods. The initialisation method will clear out the players array and assign a instantiatiation of the Ball function to the ball method. It won't need to be passed any arguments as we set up defaults for it to start in the middle of the game board. We'll also push two instantiations of the Player function into the players array. We'll make them both cpu players to start with by passing false as the second argument. The reset method will simply instantiate a new Ball and assign it to the ball variable.",
    "p22": "Our main method will be where the magic happens. We're using requestAnimationFrame, so it will be passed the time since the page loaded by that. We'll invoke each of the functions we created above within our main method and we'll also invoke our renderRect method to render the ball and the players. The default rendering method for the canvas is to render items on top of one another, covering the previous items where needed, so the ordering here is important. Finally, we'll call requestAnimationFrame again.",
    "p23": "At the end of our code, well invoke our initialisation method and also call requestAnimationFrame, passing our main method as it's only argument. If all's gone according to plan, we should have something that looks like this:",
    "p24": "We've written a fair amount of code, and so far all we have to show for it is a static image, that should be updating at about 60fps. It's time to start on the update method for the ball.",
    "p25": "Phew, there's a lot going on there! Lets break it down.",
    "p26": "We'll be creating an update method and adding it to Balls prototype, so that it's available for all Balls without having to create it each time we instatiate a new ball. First up we declare a variable that we'll use to check if the ball has been hit. Whenever the player on the left hand side hits the ball, we'll spawn an invisible ball, going slightly faster than the visible ball. If the player on the right hand side is computer controlled, it will follow this ball instead. This gives the appearance that the cpu is predicting the balls path. All an invisible ball needs to do is progess to the other side of the screen, maintaining the same trajectory as the visible ball and bouncing off the top of the screen.",
    "p27": "Each frame, we check to see if the balls x value is equal to the opposing players paddle. If it isn't, we incrememnt it's x and y values by it's x and y velocities. We also check to see if the balls y value, is equal to the border width on each side of the canvas and if so, invert the y velocity so the ball goes in the opposite direction. Finally, the remainder of the function isbn't requred for an invisible ball, so we return.",
    "p28": "Next we handle check to see if there is a collosion between the ball and either of the players by passing the ball and the player to the collision detection function we created earlier. If there is a collision, we set the x value of the ball to the correct side of the paddle, to prevent the ball getting 'stuck' within the paddle. We then set our hit variable to true. If the left paddle is hit, we instatiate a new invisible ball, passing in the existing balls properties as arguments. If the paddle on the right is hit we set the invisiball variable to undefined.",
    "p29": "Now we handle scoring, which will occur if the ball passes a player and reaches the other side of the screen. We check if the ball has reached wither side of the screen. If so, we increment the relevant players score by one. Then we use a ternary operator return either the reset or intialisation methods dependent on the score.",
    "p30": "Last, but certainly not least, we need to update the balls values. If the hit variable has been set to true, we invert the balls x velocity. We then check if the ball has reached the top and bottom borders, and if so, invert the y velocity. Then, we increment the x and y values by there related velocities multiplying by the correct measurement unit and deltaTime to ensure the ball moves the required amount of units per second regardless of frame rate. We just need one more line to prevent the ball getting 'stuck' at either the top or the bottom of the screen. We'll use the same idea as we did for hittin the paddles, where we set the y value of the ball if the ball has passed the top or bottom of the screen",
    "p31": "That's by far the toughest bit of code completed. If you were to add the balls update method into the main method now and render it with out render rect method, it should merrily bounce around the screen scoring points for invisible players. But there's still work to be done. Onwards with the update player method.",
    "p32": "We'll create the players update function in the same we crated the function for the ball and attach it to the prototype of the Player. First we'll declare a couple of variables. One for the center of the paddle being updated and one for the update increment.",
    "p33": "A player can be human or CPU controlled. We'll handle both of thee cases here. The human case is simple enough, if the players upPressed boolean is true, the player moves up, if the downPressed boolean is true, the player moves down and if neither is true, the player doesn't move. We'll be setting these booleans in the next section, once we've set up the event listeners.",
    "p34": "Handling a CPU is a little more complex. First we check the courtside for the player and the direction of the ball. We don't want the cpu players to chase a ball moving away from them. If the balls going towards the player, we use a ternary operator to check if there is an invisible ball. We then move the paddle up or down dependent on the ball or invisiaballs position relationally to the center of the paddle. Lastly we clamp the players y position so it can't get stuck to the top or bottom of the board, the same way we did with the ball.",
    "p35": "We're almost at the home straight. Now we'll be adding event listeners so that a human controlled paddle can be controlled with key board.",
    "p36": "For the event listeners, we're just going to do something quite basic. There are a lot more concise ways of handling this, but as we're only using two keys, this will more than suffice. We'll add both a keyup and a keydown listener to the document. On each listener, we'll check the keycode of each event to check if it's the up key, 38, or the down key, 40. If the key is pressed we'll set the relelevant boolean on the first player to true. When the key is releases, we set the boolean to false.",
    "p37": "You'll also notice that we are preventing the default action when the up and down keys are pressed. Think very carefully before doing something like this. I'd say it's only appropriate for a full screen game. Disabling default actions can cause a lot of accessibility issues. A user that doesn't use a mouse or mouselike device could no longer navigate the page.",
    "p38": "All that's left to do now is a quick change in our initialisation method and adding our new functions to our main method",
    "p39": "In our initialisation, method, for the first player that is passed to the players array, change the isHuman argument to true. This will make create a one player game instead of a demo game.",
    "p40": "Finally, in our main method, add the invocations of the update and ball and update player methods just before the render methods. Finally add an if statement above the call to requestAnimationFrame within the main method to check if there is an invisible ball, and if so, call it's update method. As I final check, make sure that all of the code is wrapped within the immediately invoked function. I've included the complete code below so you've got something to check against.",
    "p41": "So that wraps it up. I hope you enjoyed the tutorial and got a lot out of it. Have a play around with the code and see what you can do with it. I've tried to build it in a way that it can be added to easily. Try adding two player support, or mouse and touch controls. If you enoyed it, be sure to check out my other tutorials.",
    "pageLink1": "Introduction",
    "pageLink2": "Setting up",
    "pageLink3": "Game board",
    "pageLink4": "Ball",
    "pageLink5": "Players"
}
